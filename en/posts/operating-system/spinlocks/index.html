<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Operating System - Spinlocks | Amjad Alsharafi</title>
<meta name=keywords content="operating system,rust,locks"><meta name=description content="Talking about implementing spinlocks safely with Rust in an operating system"><meta name=author content="Amjad"><link rel=canonical href=https://amjad.alsharafi.dev/en/posts/operating-system/spinlocks/><link crossorigin=anonymous href=/assets/css/stylesheet.fb6b2b389d367570c345e9a7d7aeabb04679403de8a4f329d93b470de0d59c79.css integrity="sha256-+2srOJ02dXDDRemn166rsEZ5QD3opPMp2TtHDeDVnHk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://amjad.alsharafi.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://amjad.alsharafi.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://amjad.alsharafi.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://amjad.alsharafi.dev/apple-touch-icon.png><link rel=mask-icon href=https://amjad.alsharafi.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://amjad.alsharafi.dev/en/posts/operating-system/spinlocks/><link rel=alternate hreflang=ar href=https://amjad.alsharafi.dev/ar/posts/operating-system/spinlocks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-N62ZER16LZ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N62ZER16LZ",{anonymize_ip:!1})}</script><meta property="og:title" content="Operating System - Spinlocks"><meta property="og:description" content="Talking about implementing spinlocks safely with Rust in an operating system"><meta property="og:type" content="article"><meta property="og:url" content="https://amjad.alsharafi.dev/en/posts/operating-system/spinlocks/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-03T05:00:00+08:00"><meta property="article:modified_time" content="2023-12-05T09:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Operating System - Spinlocks"><meta name=twitter:description content="Talking about implementing spinlocks safely with Rust in an operating system"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Operating System - Spinlocks","item":"https://amjad.alsharafi.dev/en/posts/operating-system/spinlocks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Operating System - Spinlocks","name":"Operating System - Spinlocks","description":"Talking about implementing spinlocks safely with Rust in an operating system","keywords":["operating system","rust","locks"],"articleBody":"Recently, I’ve been working on a small operating system in Rust (OS), one my goals in this project is building as much as I can from scratch (at the time of writing, 0 dependencies), of course you don’t have to do that, but I think this is a good learning opportunity.\nAnyway, one of the important things in an operating system is synchronization, since most resources in the kernel is shared between multiple cores, we need to make sure that only one core can access a resource at a time, and that’s where locks come in.\nEven though I’m saying “operating systems” here, this kind of locking is used in any bare-metal application, like embedded systems, or even in user-space applications.\nI’m using Rust here for implementation, but this is not a Rust specific post, and you can implement it in any language you want, the idea is the same.\nWhat is a lock? A lock is a synchronization primitive that allows only one core/thread to access a resource at a time, when another core/thread tries to access the resource, it will be blocked until the first core/thread releases the lock, and thus, we can make sure only one has access to the resource at a time.\nHow a process inside an operating system use locks? Inside a normal operating system, a process is running multiple threads, and the operating system manages these threads, the operating system also provide you a way so that you can create a locking mechanism between your threads.\nFor example, in Linux, you can use the pthread_mutex_lock/unlock functions to lock/unlock a mutex object. The mutex here is a synchronization primitive that allows only one thread to access a resource at a time, and that’s how you can synchronize your threads.\nIn windows, you can use the AcquireSRWLockExclusive/ReleaseSRWLockExclusive functions to lock/unlock an SRW Lock object.\nSo, its an API provided by the operating system to allow efficient synchronization between threads. When the thread is waiting for a lock, it enters into a waiting state, and thus doesn’t consume a lot of CPU time.\nHow can we implement locks in an operating system? Inside a kernel, we don’t have a parent operating system to provide us with a locking mechanism, so we have to do it ourselves somehow.\nAnd here comes the spinlock, a spinlock is a lock that busy-waits until the lock is available, so if you have 2 cores, and one core is holding the lock, the other core will be stuck in a loop waiting for the lock to be unlocked, and then it will acquire it.\nImplementing a spinlock Ok, so we have the first idea in our mind now, let’s implement it.\nLet’s say we have a function handle_resource that perform some action on a shared resource, and we want to make sure that only one core can access the resource at a time, so we will use a spinlock to do that.\nThe resource will reside in a static variable, since we want to access it from anywhere. We will implement the lock in multiple iterations and explain what’s the issue with each one.\nVersion 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct Spinlock { locked: bool, } impl Spinlock { fn new() -\u003e Self { Self { locked: false, } } fn lock(\u0026mut self) { while self.locked { // spin } self.locked = true; } fn unlock(\u0026mut self) { self.locked = false; } } static mut GLOBAL_LOCK: Spinlock = Spinlock::new(); static mut GLOBAL_RESOURCE: u32 = 0; // this will be called from multiple cores fn kernel_main() { unsafe { // SAFETY: is this safe? GLOBAL_LOCK.lock(); // SAFETY: we know that we are the only core accessing this resource // so its safe to access it GLOBAL_RESOURCE += 1; GLOBAL_LOCK.unlock(); } } Here, we implemented a spinlock by using a bool variable, we have a lock function that busy-waits until the lock is available, and then we set the locked variable to true, and we have an unlock function that sets the locked variable to false.\nBut it has a big issue, there is a gap between the while loop and setting the locked variable to true, and in this gap, another core can take the lock but we won’t know about it, and thus, we will have 2 cores accessing the resource at the same time.\nShowing the issue in a diagram:\nCore 1: lock() Core 1: self.locked == false // not locked, proceed to setting it to true Core 2: lock() Core 2: self.locked == false // not locked, proceed to setting it to true Core 1: self.locked = true Core 2: self.locked = true // both cores have the lock now Let’s try to fix this issue.\nVersion 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 use core::sync::atomic::{AtomicBool, Ordering}; struct Spinlock { locked: AtomicBool, } impl Spinlock { fn new() -\u003e Self { Self { locked: AtomicBool::new(false), } } fn lock(\u0026self) { while self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_err() { // spin } } fn unlock(\u0026self) { self.locked.store(false, Ordering::Release); } } static GLOBAL_LOCK: Spinlock = Spinlock::new(); static mut GLOBAL_RESOURCE: u32 = 0; // this will be called from multiple cores fn kernel_main() { GLOBAL_LOCK.lock(); unsafe { // SAFETY: we know that we are the only core accessing this resource // so its safe to access it GLOBAL_RESOURCE += 1; } GLOBAL_LOCK.unlock(); } So, here we are using an AtomicBool instead of a normal bool, and we are using the compare_exchange function to set the locked variable to true somehow? Also if you noticed, the lock now is immutable, and we are using \u0026self instead of \u0026mut self, and thus allowing us to use it from static without any unsafe code.\nBut how does it work?\nAn AtomicBool is a boolean value that can be accessed atomically, meaning that each operation done on this type is done atomically, i.e. the whole operation is done as a single unit, and thus, no other core can access the variable in the middle of the operation.\nThe compare_exchange function is an atomic operation that compares the value of the variable with the first argument, and if they are equal, it sets the value of the variable to the second value atomically, no two cores can set the value at the same time, only one will win the race. The function then returns Ok if the operation was successful, and Err otherwise (please look at the documentation for more information).\nBecause of how atomic works, rust can make the functions use \u0026self instead of \u0026mut self, since it can guarantee that no other core can access the variable at the same time. And thus we can reduce the unsafe code.\nAnother thing to notice is the Ordering argument, it specifies the synchronization ordering of the operation, and how it affects other memory accesses around the atomic operation.\nFor a very very basic explanation, Ordering::Acquire will ensure that all memory operations before the atomic operation will be visible to other cores, and Ordering::Release will ensure that all memory operations after the atomic operation will be visible to other cores. Ordering::Relaxed is the weakest ordering, and it doesn’t guarantee anything on the other operations, but it just guarantees that the memory touched by the atomic operation will be visible to other cores (For more information about this check the documentation or Book: Rust Atomics and Locks)\nSo great, we fixed the issue, right? Well, yes, but there is another issue.\nThis issue is only specific to implementing a kernel, and that’s interrupts.\nWhen you are inside the kernel, you don’t just fear other cores, you also fear yourself. You can find yourself behind your back without even noticing :D\nHere is how it might happen.\nCore 1: lock() Core 1: self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) == Ok // lock is now locked, and we are doing some work here, and we haven't finished... // ... [interrupt] Core 1: lock() // same lock again Core 1: while self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) == Err // stuck forever.... And that’s my friends, is called a deadlock.\nA deadlock is a situation where a thread is waiting for a lock that it already holds, and thus, it will never be able to acquire the lock.\nSo, how can we fix this issue?\nVersion 3 One way to fix this is by disallowing the CPU from receiving interrupts while we are holding the lock, so we won’t be interrupted and getting into this situation.\nHere, I’m just implementing it for an x86-64 CPU, so this part is CPU specific, but the idea is the same for other CPUs with other instructions.\nI’ll not repeat old code that doesn’t change\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 struct Cpu { old_interrupt_state: bool, number_pushed: u32, } impl Cpu { fn push_interrupt_disable(\u0026mut self) { if self.number_pushed == 0 { self.old_interrupt_state = cpu_specific::current_interrupt(); cpu_specific::disable_interrupts(); } self.number_pushed += 1; } fn pop_interrupt_disable(\u0026mut self) { self.number_pushed -= 1; if self.number_pushed == 0 { if self.old_interrupt_state { x86_64::instructions::interrupts::enable(); } } } } fn current_cpu() -\u003e \u0026'static mut Cpu { // ... // get a static variable or something // we can use an array hosting all the CPUs structs for example, // and ensuring an index is only usable by one core } impl Spinlock { fn lock(\u0026self) { current_cpu().push_interrupt_disable(); while self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_err() { // spin } } fn unlock(\u0026self) { self.locked.store(false, Ordering::Release); current_cpu().pop_interrupt_disable(); } } Alright, thats a lot of code. Let’s explain it.\nSo, we had our plan of disabling interrrupts. But how can we do this safely.\nIf we just perform naively cpu::disable_interrupts() for example inside the lock, and then cpu::enable_interrupts() inside the unlock, we will have a problem, since it will fail if we have nested locks.\nLet’s see\nCore 1: Lock1::lock() Core 1: cpu::disable_interrupts() Core 1: self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) == Ok // lock is now locked, and we won't get interrupts // ... Core 1: Lock2::lock() Core 1: cpu::disable_interrupts() // already disabled, but whatever Core 1: self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) == Ok // lock is now locked, and we won't get interrupts // ... Core 1: Lock2::unlock() Core 1: self.locked.store(false, Ordering::Release) Core 1: cpu::enable_interrupts() // interrupts are now enabled // ... [interrupt] Core 1: Lock1::lock() // same lock again, and we got to the same issue, since we enabled interrupts where we shouldn't So, we have to fix this issue, this can easily be fixed by remembering how many times we are disabling interrupts, and go backwards, enabling interrupts after we know that no one is expecting the interrupts to be disabled.\nThe above example will be like so with the implementation of push_interrupt_disable and pop_interrupt_disable,\nwe don’t need to use atomic when incrementing number_pushed, since the addition line will only be executed once we disable the interrupts, and this struct should only be used by one owner core, i.e. other cores won’t execute this code at all (This is not implemented here, I’m leaving it as an exercise for the reader).\nCore 1: Lock1::lock() Core 1: push_interrupt_disable() // interrupt=false, number_pushed=1 Core 1: self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) == Ok // lock is now locked, and we won't get interrupts // ... Core 1: Lock2::lock() Core 1: push_interrupt_disable() // interrupt=false, number_pushed=2 Core 1: self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed) == Ok // lock is now locked, and we won't get interrupts // ... Core 1: Lock2::unlock() Core 1: self.locked.store(false, Ordering::Release) Core 1: pop_interrupt_disable() // interrupt=false, number_pushed=1 // interrupts are still disabled // ... Core 1: Lock1::unlock() Core 1: self.locked.store(false, Ordering::Release) Core 1: pop_interrupt_disable() // interrupt=true, number_pushed=0 // interrupts are now enabled and all safe And yeah, that’s it, we have a working spinlock now. I think that this is safe from all issues that I found, but if you found any issue, please let me know :)\nRustifying We have a lock now, but using it is ugly, look at this:\n1 2 3 4 5 6 7 GLOBAL_LOCK.lock(); unsafe { // SAFETY: we know that we are the only core accessing this resource so its safe to access it GLOBAL_RESOURCE += 1; } GLOBAL_LOCK.unlock(); We can make it better by creating a type that holds the data and lock, and handles all the unsafe stuff for us so we don’t have to do that.\nWe can get inspiration from the Mutex type in the standard library.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 use core::{cell::UnsafeCell, ops::{Deref, DerefMut}}; // you can put this in `spin::Mutex` or something struct SpinMutex\u003cT\u003e { lock: Spinlock, data: UnsafeCell\u003cT\u003e, } // impl extra stuff here, like `unsafe Send/Sync`, `Debug`, I won't go into details here impl\u003cT\u003e SpinMutex\u003cT\u003e { fn new(data: T) -\u003e Self { Self { lock: Spinlock::new(), data: UnsafeCell::new(data), } } fn lock(\u0026self) -\u003e SpinMutexGuard\u003c'_, T\u003e { self.lock.lock(); SpinMutexGuard { lock: \u0026self.lock, // SAFETY: we know that we are the only core accessing this resource so its safe to access it data: unsafe { \u0026mut *self.data.get() }, } } // extra function here fn try_lock(\u0026self) -\u003e Option\u003cSpinMutexGuard\u003c'_, T\u003e\u003e { // `try_lock` here just performs `lock` but without looping // it will return `true` if the lock was acquired, and `false` otherwise if self.lock.try_lock() { Some(SpinMutexGuard { lock: \u0026self.lock, data: unsafe { \u0026mut *self.data.get() }, }) } else { None } } fn unlock(\u0026self) { self.lock.unlock(); } } struct SpinMutexGuard\u003c'a, T\u003e { lock: \u0026'a Spinlock, data: \u0026'a mut T, } impl \u003c'a, T\u003e Deref for SpinMutexGuard\u003c'a, T\u003e { type Target = T; fn deref(\u0026self) -\u003e \u0026Self::Target { self.data } } impl \u003c'a, T\u003e DerefMut for SpinMutexGuard\u003c'a, T\u003e { fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target { self.data } } impl\u003cT\u003e Drop for SpinMutexGuard\u003c'_, T\u003e { fn drop(\u0026mut self) { self.lock.unlock(); } } // usage static GLOBAL_RESOURCE: SpinMutex\u003cu32\u003e = SpinMutex::new(0); fn kernel_main() { let mut guard = GLOBAL_RESOURCE.lock(); *guard += 1; // guard is dropped here, and the lock is unlocked } Here, we use UnsafeCell to keep the data. We do this because we want to change the data inside even if we have a shared reference to it. So, we have to let the compiler know we’re aware of the risks, and that’s why we use unsafe.\nWhen we lock the Mutex, we get a SpinMutexGuard back that has a reference to the data. When it’s done, it unlocks the lock. Since it has a reference to the lock inside, we’re sure no other core can use the lock at the same time. So, we can safely use it and then unlock it.\nSpinMutexGuard implements Deref and DerefMut to make it easy to get to the data inside. It also implements Drop so that the lock gets unlocked when it’s not needed anymore (like when it goes out of scope). This saves us from having to manually call unlock (RAII).\nAnd that’s mainly it, we have a nice spinlock now, and we can use it easily.\nExtra small improvements Another thing I left for last, since it doesn’t affect functionality, but it is a nice improvement.\nAnd that’s using core::hint::spin_loop instead of an empty loop, this will hint the compile/cpu that we are spinning, and thus, it can optimize it better.\n1 2 3 4 5 fn lock(\u0026self) { while self.locked.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed).is_err() { core::hint::spin_loop(); } } Another thing (Thanks to zypeh) is using core::sync::atomic::AtomicUsize instead of core::sync::atomic::AtomicBool, or by using crossbeam_utils::CachePadded to make sure that the lock is not in the same cache line as other variables, and thus, we can avoid false sharing, and improve performance.\nIssues This Mutex we have now is good, but there are several issues.\nSpin Of course, this is a spin lock, and will waste time if the lock is held for a long time, there are other types of locks that try to be more fair, or give another task for the core to do while waiting for the lock, I don’t know what exactly, but when I implement it, I’ll create a new post on it :D\nAnother type of deadlock Imagine you are using a lock inside the Console type for example, this is a type that you have implemented to print messages to the serial/display, you will need to use a lock here so that only one core prints at a time.\nNow imagine, that this Console somehow panics, and you have a panic handler that prints the panic message. This is not a CPU interrupt, but a feature in rust that transfer execution into a specific panic_handler.\nThis will generate a deadlock, since the panic_handler will try to lock the Console to print the message, but the Console is already locked by the core that panicked, and thus, we will have a deadlock.\nFor this one, you can have a special type of Mutex that allows you to lock it multiple times by the same core only. And this type of lock is actually used in the standard library internally, and it is called ReentrantMutex. The standard library implements it with owner thread, we can just replace it with core.\nBut of course, this is only useable in these few places that arrise this issue, and not in general. And when you get the lock again, you have to make sure that you are not causing any issues with the data inside, there won’t be another user at the same time, but the mutable state should be always valid.\nIn the standard library this is used as a wrapper for stdout and stderr. (example: ReentrantMutex","wordCount":"3145","inLanguage":"en","datePublished":"2023-12-03T05:00:00+08:00","dateModified":"2023-12-05T09:00:00+08:00","author":{"@type":"Person","name":"Amjad"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://amjad.alsharafi.dev/en/posts/operating-system/spinlocks/"},"publisher":{"@type":"Organization","name":"Amjad Alsharafi","logo":{"@type":"ImageObject","url":"https://amjad.alsharafi.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://amjad.alsharafi.dev/en/ accesskey=h title="Amjad Alsharafi (Alt + H)">Amjad Alsharafi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://amjad.alsharafi.dev/ar/ title=العربية aria-label=العربية>العربية</a></li></ul></div></div><ul id=menu><li><a href=https://amjad.alsharafi.dev/en/about title=About><span>About</span></a></li><li><a href=https://amjad.alsharafi.dev/en/series title=Series><span>Series</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://amjad.alsharafi.dev/en/>Home</a></div><h1 class=post-title>Operating System - Spinlocks</h1><div class=post-description>Talking about implementing spinlocks safely with Rust in an operating system</div><div class=post-meta><span title='2023-12-03 05:00:00 +0800 +0800'>December 3, 2023</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Amjad&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://amjad.alsharafi.dev/ar/posts/operating-system/spinlocks/>العربية</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/Amjad50/amjad50.github.io/tree/master/content/posts/operating%20system/spinlocks/index.md rel="noopener noreferrer" target=_blank>Suggest changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#what-is-a-lock>What is a lock?</a></li><li><a href=#how-a-process-inside-an-operating-system-use-locks>How a process inside an operating system use locks?</a></li><li><a href=#how-can-we-implement-locks-in-an-operating-system>How can we implement locks in an operating system?</a></li><li><a href=#implementing-a-spinlock>Implementing a spinlock</a><ul><li><a href=#version-1>Version 1</a></li><li><a href=#version-2>Version 2</a></li><li><a href=#version-3>Version 3</a></li></ul></li><li><a href=#rustifying>Rustifying</a></li><li><a href=#extra-small-improvements>Extra small improvements</a></li><li><a href=#issues>Issues</a><ul><li><a href=#spin>Spin</a></li><li><a href=#another-type-of-deadlock>Another type of deadlock</a></li></ul></li><li><a href=#conclusion-and-acknowledgements>Conclusion and acknowledgements</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Recently, I&rsquo;ve been working on a small operating system in <a href=https://www.rust-lang.org/><code>Rust</code></a> (<a href=https://github.com/Amjad50/OS>OS</a>), one my goals in this project is building
as much as I can from scratch (at the time of writing, 0 dependencies), of course you don&rsquo;t have to do that, but
I think this is a good learning opportunity.</p><p>Anyway, one of the important things in an operating system is synchronization, since most resources in the kernel
is shared between multiple cores, we need to make sure that only one core can access a resource at a time, and
that&rsquo;s where locks come in.</p><blockquote><p>Even though I&rsquo;m saying &ldquo;operating systems&rdquo; here, this kind of locking is used in any bare-metal application, like
embedded systems, or even in user-space applications.</p></blockquote><blockquote><p>I&rsquo;m using <a href=https://www.rust-lang.org/><code>Rust</code></a> here for implementation, but this is not a Rust specific post, and you can implement it in any
language you want, the idea is the same.</p></blockquote><h2 id=what-is-a-lock>What is a lock?<a hidden class=anchor aria-hidden=true href=#what-is-a-lock>#</a></h2><p>A lock is a synchronization primitive that allows only one core/thread to access a resource at a time, when another
core/thread tries to access the resource, it will be blocked until the first core/thread releases the lock, and thus, we can make sure only one has access to the resource at a time.</p><h2 id=how-a-process-inside-an-operating-system-use-locks>How a process inside an operating system use locks?<a hidden class=anchor aria-hidden=true href=#how-a-process-inside-an-operating-system-use-locks>#</a></h2><p>Inside a normal operating system, a process is running multiple threads, and the operating system manages these
threads, the operating system also provide you a way so that you can create a locking mechanism between your threads.</p><p>For example, in Linux, you can use the <a href=https://linux.die.net/man/3/pthread_mutex_lock><code>pthread_mutex_lock/unlock</code></a> functions to lock/unlock a mutex object.
The <code>mutex</code> here is a synchronization primitive that allows only one thread to access a resource at a time, and
that&rsquo;s how you can synchronize your threads.</p><p>In windows, you can use the <a href=https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-acquiresrwlockexclusive><code>AcquireSRWLockExclusive</code></a>/<a href=https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesrwlockexclusive><code>ReleaseSRWLockExclusive</code></a> functions to lock/unlock an <a href=https://docs.microsoft.com/en-us/windows/win32/sync/slim-reader-writer--srw--locks>SRW Lock</a> object.</p><p>So, its an API provided by the operating system to allow efficient synchronization between threads. When the thread
is waiting for a lock, it enters into a waiting state, and thus doesn&rsquo;t consume a lot of CPU time.</p><h2 id=how-can-we-implement-locks-in-an-operating-system>How can we implement locks in an operating system?<a hidden class=anchor aria-hidden=true href=#how-can-we-implement-locks-in-an-operating-system>#</a></h2><p>Inside a kernel, we don&rsquo;t have a parent operating system to provide us with a locking mechanism, so we have to
do it ourselves somehow.</p><p>And here comes the <strong>spinlock</strong>, a <strong>spinlock</strong> is a lock that busy-waits until the lock is available, so if you have 2 cores, and one
core is holding the lock, the other core will be stuck in a loop waiting for the lock to be unlocked, and then it will acquire it.</p><h2 id=implementing-a-spinlock>Implementing a spinlock<a hidden class=anchor aria-hidden=true href=#implementing-a-spinlock>#</a></h2><p>Ok, so we have the first idea in our mind now, let&rsquo;s implement it.</p><p>Let&rsquo;s say we have a function <code>handle_resource</code> that perform some action on a shared resource, and we want to make sure
that only one core can access the resource at a time, so we will use a spinlock to do that.</p><p>The resource will reside in a static variable, since we want to access it from anywhere. We will implement the lock in multiple iterations and explain
what&rsquo;s the issue with each one.</p><h3 id=version-1>Version 1<a hidden class=anchor aria-hidden=true href=#version-1>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Spinlock</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>locked</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Spinlock</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>locked</span>: <span class=nc>false</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// spin
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=no>GLOBAL_LOCK</span>: <span class=nc>Spinlock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Spinlock</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=no>GLOBAL_RESOURCE</span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// this will be called from multiple cores
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>kernel_main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// SAFETY: is this safe?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=no>GLOBAL_LOCK</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// SAFETY: we know that we are the only core accessing this resource
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>//         so its safe to access it
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=no>GLOBAL_RESOURCE</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=no>GLOBAL_LOCK</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Here, we implemented a spinlock by using a <code>bool</code> variable, we have a <code>lock</code> function that busy-waits until the lock is available, and then
we set the <code>locked</code> variable to <code>true</code>, and we have an <code>unlock</code> function that sets the <code>locked</code> variable to <code>false</code>.</p><p>But it has a big issue, there is a gap between the <code>while</code> loop and setting the <code>locked</code> variable to <code>true</code>, and in this gap, another core can
take the lock but we won&rsquo;t know about it, and thus, we will have 2 cores accessing the resource at the same time.</p><p>Showing the issue in a diagram:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>false</span><span class=w>    </span><span class=c1>// not locked, proceed to setting it to true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Core</span><span class=w> </span><span class=mi>2</span>: <span class=nc>lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>2</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>false</span><span class=w>    </span><span class=c1>// not locked, proceed to setting it to true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>2</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// both cores have the lock now
</span></span></span></code></pre></div><p>Let&rsquo;s try to fix this issue.</p><h3 id=version-2>Version 2<a hidden class=anchor aria-hidden=true href=#version-2>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=hl><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span></span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=hl><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span></span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=hl><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span></span><span class=hl><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span></span><span class=hl><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span></span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=hl><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span></span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=hl><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span></span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=hl><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span></span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span><span class=lnt id=hl-2-36><a class=lnlinks href=#hl-2-36>36</a>
</span><span class=hl><span class=lnt id=hl-2-37><a class=lnlinks href=#hl-2-37>37</a>
</span></span><span class=lnt id=hl-2-38><a class=lnlinks href=#hl-2-38>38</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=n>sync</span>::<span class=n>atomic</span>::<span class=p>{</span><span class=n>AtomicBool</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Spinlock</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>    </span><span class=n>locked</span>: <span class=nc>AtomicBool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Spinlock</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>            </span><span class=n>locked</span>: <span class=nc>AtomicBool</span>::<span class=n>new</span><span class=p>(</span><span class=kc>false</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>).</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>            </span><span class=c1>// spin
</span></span></span><span class="line hl"><span class=cl><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Release</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=no>GLOBAL_LOCK</span>: <span class=nc>Spinlock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Spinlock</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=no>GLOBAL_RESOURCE</span>: <span class=kt>u32</span> <span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// this will be called from multiple cores
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>kernel_main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>    </span><span class=no>GLOBAL_LOCK</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// SAFETY: we know that we are the only core accessing this resource
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>//         so its safe to access it
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=no>GLOBAL_RESOURCE</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>    </span><span class=no>GLOBAL_LOCK</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>So, here we are using an <a href=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html><code>AtomicBool</code></a> instead of a normal <code>bool</code>, and we are using the <a href=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.compare_exchange><code>compare_exchange</code></a> function to set the <code>locked</code> variable to <code>true</code> somehow? Also if you noticed, the lock now is immutable, and we are using <code>&amp;self</code> instead of <code>&amp;mut self</code>, and thus allowing us to use it from <code>static</code> without any <code>unsafe</code> code.</p><p>But how does it work?</p><p>An <a href=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html><code>AtomicBool</code></a> is a boolean value that can be accessed atomically, meaning that each operation done on this type is done atomically, i.e. the whole operation is done as a single unit, and thus, no other core can access the variable in the middle of the operation.</p><p>The <a href=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.compare_exchange><code>compare_exchange</code></a> function is an atomic operation that compares the value of the variable with the first argument, and if they are equal, it sets the value
of the variable to the second value atomically, no two cores can set the value at the same time, only one will win the race. The function then returns <code>Ok</code> if
the operation was successful, and <code>Err</code> otherwise (please look at the documentation for more information).</p><p>Because of how atomic works, rust can make the functions use <code>&amp;self</code> instead of <code>&amp;mut self</code>, since it can guarantee that no other core can access the variable
at the same time. And thus we can reduce the <code>unsafe</code> code.</p><p>Another thing to notice is the <a href=https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html><code>Ordering</code></a> argument, it specifies the synchronization ordering of the operation, and how it affects other memory accesses around
the atomic operation.</p><p>For a very very basic explanation, <code>Ordering::Acquire</code> will ensure that all memory operations before the atomic operation will be visible to other cores,
and <code>Ordering::Release</code> will ensure that all memory operations after the atomic operation will be visible to other cores.
<code>Ordering::Relaxed</code> is the weakest ordering, and it doesn&rsquo;t guarantee anything on the other operations, but it just guarantees that the memory touched by the
atomic operation will be visible to other cores (For more information about this check the documentation or <a href=https://marabos.nl/atomics/>Book: Rust Atomics and Locks</a>)</p><p>So great, we fixed the issue, right? Well, yes, but there is another issue.</p><p>This issue is only specific to implementing a kernel, and that&rsquo;s <code>interrupts</code>.</p><p>When you are inside the kernel, you don&rsquo;t just fear other cores, you also fear yourself. You can find yourself behind your back
without even noticing :D</p><p>Here is how it might happen.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Ok</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// lock is now locked, and we are doing some work here, and we haven&#39;t finished...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>[</span><span class=n>interrupt</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>lock</span><span class=p>()</span><span class=w>  </span><span class=c1>// same lock again
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>while</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// stuck forever....
</span></span></span></code></pre></div><p>And that&rsquo;s my friends, is called a <strong>deadlock</strong>.</p><p>A deadlock is a situation where a thread is waiting for a lock that it already holds, and thus, it will never be able to acquire the lock.</p><p>So, how can we fix this issue?</p><h3 id=version-3>Version 3<a hidden class=anchor aria-hidden=true href=#version-3>#</a></h3><p>One way to fix this is by disallowing the CPU from receiving interrupts while we are holding the lock, so we won&rsquo;t be interrupted and getting into this situation.</p><p>Here, I&rsquo;m just implementing it for an <code>x86-64</code> CPU, so this part is CPU specific, but the idea is the same for other CPUs with other instructions.</p><blockquote><p>I&rsquo;ll not repeat old code that doesn&rsquo;t change</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=hl><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span></span><span class=hl><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span></span><span class=hl><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span></span><span class=hl><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span></span><span class=hl><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span></span><span class=hl><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span></span><span class=hl><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span></span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=hl><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span></span><span class=hl><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span></span><span class=hl><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span></span><span class=hl><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span></span><span class=hl><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span></span><span class=hl><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span></span><span class=hl><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span></span><span class=hl><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span></span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=hl><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span></span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=hl><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span></span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=hl><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span></span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Cpu</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>old_interrupt_state</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>number_pushed</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Cpu</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>push_interrupt_disable</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>number_pushed</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>old_interrupt_state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cpu_specific</span>::<span class=n>current_interrupt</span><span class=p>();</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>            </span><span class=n>cpu_specific</span>::<span class=n>disable_interrupts</span><span class=p>();</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>number_pushed</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>pop_interrupt_disable</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>number_pushed</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>number_pushed</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>old_interrupt_state</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>                </span><span class=n>x86_64</span>::<span class=n>instructions</span>::<span class=n>interrupts</span>::<span class=n>enable</span><span class=p>();</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>current_cpu</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=nc>mut</span><span class=w> </span><span class=n>Cpu</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// get a static variable or something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// we can use an array hosting all the CPUs structs for example, 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// and ensuring an index is only usable by one core
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Spinlock</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=n>current_cpu</span><span class=p>().</span><span class=n>push_interrupt_disable</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>).</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// spin
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Release</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>current_cpu</span><span class=p>().</span><span class=n>pop_interrupt_disable</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Alright, thats a lot of code. Let&rsquo;s explain it.</p><p>So, we had our plan of disabling interrrupts. But how can we do this safely.</p><p>If we just perform naively <code>cpu::disable_interrupts()</code> for example inside the <code>lock</code>, and then <code>cpu::enable_interrupts()</code> inside the <code>unlock</code>, we will have a problem, since it will fail if we have nested locks.</p><p>Let&rsquo;s see</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>Lock1</span>::<span class=n>lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>cpu</span>::<span class=n>disable_interrupts</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Ok</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// lock is now locked, and we won&#39;t get interrupts
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>Lock2</span>::<span class=n>lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>cpu</span>::<span class=n>disable_interrupts</span><span class=p>()</span><span class=w>   </span><span class=c1>// already disabled, but whatever
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Ok</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// lock is now locked, and we won&#39;t get interrupts
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>Lock2</span>::<span class=n>unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Release</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>cpu</span>::<span class=n>enable_interrupts</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// interrupts are now enabled
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>[</span><span class=n>interrupt</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>Lock1</span>::<span class=n>lock</span><span class=p>()</span><span class=w>  </span><span class=c1>// same lock again, and we got to the same issue, since we enabled interrupts where we shouldn&#39;t
</span></span></span></code></pre></div><p>So, we have to fix this issue, this can easily be fixed by remembering how many times we are disabling interrupts,
and go backwards, enabling interrupts after we know that no one is expecting the interrupts to be disabled.</p><p>The above example will be like so with the implementation of <a href=#hl-4-7><code>push_interrupt_disable</code></a> and <a href=#hl-4-15><code>pop_interrupt_disable</code></a>,</p><blockquote><p>we don&rsquo;t need to use <strong>atomic</strong> when incrementing <code>number_pushed</code>, since the addition line will only be executed once
we disable the interrupts, and this struct should only be used by one owner core, i.e. other cores won&rsquo;t execute this
code at all (This is not implemented here, I&rsquo;m leaving it as an exercise for the reader).</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>Lock1</span>::<span class=n>lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>push_interrupt_disable</span><span class=p>()</span><span class=w>    </span><span class=c1>// interrupt=false, number_pushed=1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Ok</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// lock is now locked, and we won&#39;t get interrupts
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>Lock2</span>::<span class=n>lock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>push_interrupt_disable</span><span class=p>()</span><span class=w>   </span><span class=c1>// interrupt=false, number_pushed=2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nb>Ok</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// lock is now locked, and we won&#39;t get interrupts
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>Lock2</span>::<span class=n>unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Release</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>pop_interrupt_disable</span><span class=p>()</span><span class=w> </span><span class=c1>// interrupt=false, number_pushed=1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// interrupts are still disabled
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>Lock1</span>::<span class=n>unlock</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Release</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Core</span><span class=w> </span><span class=mi>1</span>: <span class=nc>pop_interrupt_disable</span><span class=p>()</span><span class=w> </span><span class=c1>// interrupt=true, number_pushed=0
</span></span></span><span class=line><span class=cl><span class=c1>// interrupts are now enabled and all safe
</span></span></span></code></pre></div><p>And yeah, that&rsquo;s it, we have a working spinlock now.
I think that this is safe from all issues that I found, but if you found any issue, please let me know :)</p><h2 id=rustifying>Rustifying<a hidden class=anchor aria-hidden=true href=#rustifying>#</a></h2><p>We have a lock now, but using it is ugly, look at this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=no>GLOBAL_LOCK</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// SAFETY: we know that we are the only core accessing this resource so its safe to access it
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=no>GLOBAL_RESOURCE</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=no>GLOBAL_LOCK</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>We can make it better by creating a type that holds the data and lock, and handles all the <code>unsafe</code> stuff for us so we don&rsquo;t
have to do that.</p><p>We can get inspiration from the <a href=https://doc.rust-lang.org/std/sync/struct.Mutex.html><code>Mutex</code></a> type in the standard library.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span><span class=lnt id=hl-8-23><a class=lnlinks href=#hl-8-23>23</a>
</span><span class=lnt id=hl-8-24><a class=lnlinks href=#hl-8-24>24</a>
</span><span class=lnt id=hl-8-25><a class=lnlinks href=#hl-8-25>25</a>
</span><span class=lnt id=hl-8-26><a class=lnlinks href=#hl-8-26>26</a>
</span><span class=lnt id=hl-8-27><a class=lnlinks href=#hl-8-27>27</a>
</span><span class=lnt id=hl-8-28><a class=lnlinks href=#hl-8-28>28</a>
</span><span class=lnt id=hl-8-29><a class=lnlinks href=#hl-8-29>29</a>
</span><span class=lnt id=hl-8-30><a class=lnlinks href=#hl-8-30>30</a>
</span><span class=lnt id=hl-8-31><a class=lnlinks href=#hl-8-31>31</a>
</span><span class=lnt id=hl-8-32><a class=lnlinks href=#hl-8-32>32</a>
</span><span class=lnt id=hl-8-33><a class=lnlinks href=#hl-8-33>33</a>
</span><span class=lnt id=hl-8-34><a class=lnlinks href=#hl-8-34>34</a>
</span><span class=lnt id=hl-8-35><a class=lnlinks href=#hl-8-35>35</a>
</span><span class=lnt id=hl-8-36><a class=lnlinks href=#hl-8-36>36</a>
</span><span class=lnt id=hl-8-37><a class=lnlinks href=#hl-8-37>37</a>
</span><span class=lnt id=hl-8-38><a class=lnlinks href=#hl-8-38>38</a>
</span><span class=lnt id=hl-8-39><a class=lnlinks href=#hl-8-39>39</a>
</span><span class=lnt id=hl-8-40><a class=lnlinks href=#hl-8-40>40</a>
</span><span class=lnt id=hl-8-41><a class=lnlinks href=#hl-8-41>41</a>
</span><span class=lnt id=hl-8-42><a class=lnlinks href=#hl-8-42>42</a>
</span><span class=lnt id=hl-8-43><a class=lnlinks href=#hl-8-43>43</a>
</span><span class=lnt id=hl-8-44><a class=lnlinks href=#hl-8-44>44</a>
</span><span class=lnt id=hl-8-45><a class=lnlinks href=#hl-8-45>45</a>
</span><span class=lnt id=hl-8-46><a class=lnlinks href=#hl-8-46>46</a>
</span><span class=lnt id=hl-8-47><a class=lnlinks href=#hl-8-47>47</a>
</span><span class=lnt id=hl-8-48><a class=lnlinks href=#hl-8-48>48</a>
</span><span class=lnt id=hl-8-49><a class=lnlinks href=#hl-8-49>49</a>
</span><span class=lnt id=hl-8-50><a class=lnlinks href=#hl-8-50>50</a>
</span><span class=lnt id=hl-8-51><a class=lnlinks href=#hl-8-51>51</a>
</span><span class=lnt id=hl-8-52><a class=lnlinks href=#hl-8-52>52</a>
</span><span class=lnt id=hl-8-53><a class=lnlinks href=#hl-8-53>53</a>
</span><span class=lnt id=hl-8-54><a class=lnlinks href=#hl-8-54>54</a>
</span><span class=lnt id=hl-8-55><a class=lnlinks href=#hl-8-55>55</a>
</span><span class=lnt id=hl-8-56><a class=lnlinks href=#hl-8-56>56</a>
</span><span class=lnt id=hl-8-57><a class=lnlinks href=#hl-8-57>57</a>
</span><span class=lnt id=hl-8-58><a class=lnlinks href=#hl-8-58>58</a>
</span><span class=lnt id=hl-8-59><a class=lnlinks href=#hl-8-59>59</a>
</span><span class=lnt id=hl-8-60><a class=lnlinks href=#hl-8-60>60</a>
</span><span class=lnt id=hl-8-61><a class=lnlinks href=#hl-8-61>61</a>
</span><span class=lnt id=hl-8-62><a class=lnlinks href=#hl-8-62>62</a>
</span><span class=lnt id=hl-8-63><a class=lnlinks href=#hl-8-63>63</a>
</span><span class=lnt id=hl-8-64><a class=lnlinks href=#hl-8-64>64</a>
</span><span class=lnt id=hl-8-65><a class=lnlinks href=#hl-8-65>65</a>
</span><span class=lnt id=hl-8-66><a class=lnlinks href=#hl-8-66>66</a>
</span><span class=lnt id=hl-8-67><a class=lnlinks href=#hl-8-67>67</a>
</span><span class=lnt id=hl-8-68><a class=lnlinks href=#hl-8-68>68</a>
</span><span class=lnt id=hl-8-69><a class=lnlinks href=#hl-8-69>69</a>
</span><span class=lnt id=hl-8-70><a class=lnlinks href=#hl-8-70>70</a>
</span><span class=lnt id=hl-8-71><a class=lnlinks href=#hl-8-71>71</a>
</span><span class=lnt id=hl-8-72><a class=lnlinks href=#hl-8-72>72</a>
</span><span class=lnt id=hl-8-73><a class=lnlinks href=#hl-8-73>73</a>
</span><span class=lnt id=hl-8-74><a class=lnlinks href=#hl-8-74>74</a>
</span><span class=lnt id=hl-8-75><a class=lnlinks href=#hl-8-75>75</a>
</span><span class=lnt id=hl-8-76><a class=lnlinks href=#hl-8-76>76</a>
</span><span class=lnt id=hl-8-77><a class=lnlinks href=#hl-8-77>77</a>
</span><span class=lnt id=hl-8-78><a class=lnlinks href=#hl-8-78>78</a>
</span><span class=lnt id=hl-8-79><a class=lnlinks href=#hl-8-79>79</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>core</span>::<span class=p>{</span><span class=n>cell</span>::<span class=n>UnsafeCell</span><span class=p>,</span><span class=w> </span><span class=n>ops</span>::<span class=p>{</span><span class=n>Deref</span><span class=p>,</span><span class=w> </span><span class=n>DerefMut</span><span class=p>}};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// you can put this in `spin::Mutex` or something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>SpinMutex</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span>: <span class=nc>Spinlock</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>data</span>: <span class=nc>UnsafeCell</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// impl extra stuff here, like `unsafe Send/Sync`, `Debug`, I won&#39;t go into details here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>SpinMutex</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>data</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span>: <span class=nc>Spinlock</span>::<span class=n>new</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>data</span>: <span class=nc>UnsafeCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>data</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>SpinMutexGuard</span><span class=o>&lt;</span><span class=nb>&#39;_</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>lock</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SpinMutexGuard</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span>: <span class=kp>&amp;</span><span class=nc>self</span><span class=p>.</span><span class=n>lock</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// SAFETY: we know that we are the only core accessing this resource so its safe to access it
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=n>data</span>: <span class=nc>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=o>*</span><span class=bp>self</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>get</span><span class=p>()</span><span class=w> </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// extra function here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>try_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>SpinMutexGuard</span><span class=o>&lt;</span><span class=nb>&#39;_</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// `try_lock` here just performs `lock` but without looping
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// it will return `true` if the lock was acquired, and `false` otherwise
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lock</span><span class=p>.</span><span class=n>try_lock</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>SpinMutexGuard</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>lock</span>: <span class=kp>&amp;</span><span class=nc>self</span><span class=p>.</span><span class=n>lock</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>data</span>: <span class=nc>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=o>*</span><span class=bp>self</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>get</span><span class=p>()</span><span class=w> </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>SpinMutexGuard</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>Spinlock</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>data</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>mut</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Deref</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SpinMutexGuard</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Target</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>deref</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>Self</span>::<span class=n>Target</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>DerefMut</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SpinMutexGuard</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>deref_mut</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=bp>Self</span>::<span class=n>Target</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>data</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nb>Drop</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SpinMutexGuard</span><span class=o>&lt;</span><span class=nb>&#39;_</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>drop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// usage
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span><span class=w> </span><span class=no>GLOBAL_RESOURCE</span>: <span class=nc>SpinMutex</span><span class=o>&lt;</span><span class=kt>u32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SpinMutex</span>::<span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>kernel_main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>guard</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=no>GLOBAL_RESOURCE</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>*</span><span class=n>guard</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// guard is dropped here, and the lock is unlocked
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Here, we use <a href=https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html><code>UnsafeCell</code></a> to keep the data. We do this because we want to change the data inside even if we have a shared reference to it. So, we have to let the compiler know we&rsquo;re aware of the risks, and that&rsquo;s why we use <code>unsafe</code>.</p><p>When we lock the <code>Mutex</code>, we get a <code>SpinMutexGuard</code> back that has a reference to the data. When it&rsquo;s done, it unlocks the lock. Since it has a reference to the lock inside, we&rsquo;re sure no other core can use the lock at the same time. So, we can safely use it and then unlock it.</p><p><code>SpinMutexGuard</code> implements <a href=https://doc.rust-lang.org/std/ops/trait.Deref.html><code>Deref</code></a> and <a href=https://doc.rust-lang.org/std/ops/trait.DerefMut.html><code>DerefMut</code></a> to make it easy to get to the data inside. It also implements <a href=https://doc.rust-lang.org/std/ops/trait.Drop.html><code>Drop</code></a> so that the lock gets unlocked when it&rsquo;s not needed anymore (like when it goes out of scope). This saves us from having to manually call <code>unlock</code> (RAII).</p><p>And that&rsquo;s mainly it, we have a nice spinlock now, and we can use it easily.</p><h2 id=extra-small-improvements>Extra small improvements<a hidden class=anchor aria-hidden=true href=#extra-small-improvements>#</a></h2><p>Another thing I left for last, since it doesn&rsquo;t affect functionality, but it is a nice improvement.</p><p>And that&rsquo;s using <a href=https://doc.rust-lang.org/core/hint/fn.spin_loop.html><code>core::hint::spin_loop</code></a> instead of an empty loop, this will hint the compile/cpu that we are spinning,
and thus, it can optimize it better.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=hl><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span></span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>locked</span><span class=p>.</span><span class=n>compare_exchange</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Acquire</span><span class=p>,</span><span class=w> </span><span class=n>Ordering</span>::<span class=n>Relaxed</span><span class=p>).</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class="line hl"><span class=cl><span class=w>        </span><span class=n>core</span>::<span class=n>hint</span>::<span class=n>spin_loop</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Another thing (Thanks to <code>zypeh</code>) is using <code>core::sync::atomic::AtomicUsize</code> instead of <code>core::sync::atomic::AtomicBool</code>,
or by using <a href=https://docs.rs/crossbeam-utils/latest/crossbeam_utils/struct.CachePadded.html><code>crossbeam_utils::CachePadded</code></a> to make sure that the lock is not in the same cache line as other variables,
and thus, we can avoid false sharing, and improve performance.</p><h2 id=issues>Issues<a hidden class=anchor aria-hidden=true href=#issues>#</a></h2><p>This <code>Mutex</code> we have now is good, but there are several issues.</p><h3 id=spin>Spin<a hidden class=anchor aria-hidden=true href=#spin>#</a></h3><p>Of course, this is a spin lock, and will waste time if the lock is held for a long time, there are other types of locks that
try to be more fair, or give another task for the core to do while waiting for the lock, I don&rsquo;t know what exactly,
but when I implement it, I&rsquo;ll create a new post on it :D</p><h3 id=another-type-of-deadlock>Another type of deadlock<a hidden class=anchor aria-hidden=true href=#another-type-of-deadlock>#</a></h3><p>Imagine you are using a lock inside the <code>Console</code> type for example, this is a type that you have implemented
to print messages to the serial/display, you will need to use a lock here so that only one core prints at a time.</p><p>Now imagine, that this <code>Console</code> somehow <code>panic</code>s, and you have a <code>panic</code> handler that prints the <code>panic</code> message.
This is not a CPU interrupt, but a feature in rust that transfer execution into a specific <code>panic_handler</code>.</p><p>This will generate a deadlock, since the <code>panic_handler</code> will try to lock the <code>Console</code> to print the message, but
the <code>Console</code> is already locked by the core that panicked, and thus, we will have a deadlock.</p><p>For this one, you can have a special type of <code>Mutex</code> that allows you to lock it multiple times by the same core only.
And this type of lock is actually used in the standard library internally, and it is called <a href=https://doc.rust-lang.org/stable/src/std/sync/remutex.rs.html><code>ReentrantMutex</code></a>.
The standard library implements it with <code>owner</code> thread, we can just replace it with <code>core</code>.</p><p>But of course, this is only useable in these few places that arrise this issue, and not in general.
And when you get the lock again, you have to make sure that you are not causing any issues with the data inside, there won&rsquo;t be another user at the same time, but the mutable state should be always valid.</p><p>In the standard library this is used as a wrapper for <code>stdout</code> and <code>stderr</code>. (example:
<a href=https://doc.rust-lang.org/stable/src/std/io/stdio.rs.html#539><code>ReentrantMutex&lt;RefCell&lt;LineWriter&lt;StdoutRaw>>></code></a>)</p><h2 id=conclusion-and-acknowledgements>Conclusion and acknowledgements<a hidden class=anchor aria-hidden=true href=#conclusion-and-acknowledgements>#</a></h2><p><strong>Spinlocks</strong> are important part of any kernel, at least in the beginning before having better locking mechanisms,
and thus its important to understand how they work and how to implement them safely.</p><p>I hope this post was helpful, and if you have any questions or issues, please let me know.</p><p>This implementation was greatly inspired by the lock implementation in <a href=https://github.com/mit-pdos/xv6-public/blob/master/spinlock.c><code>xv6</code></a>, and the <a href=https://doc.rust-lang.org/std/sync/struct.Mutex.html><code>Mutex</code></a> type in the standard library.</p><p>Happy hacking :D</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://amjad.alsharafi.dev/en/tags/operating-system/>operating system</a></li><li><a href=https://amjad.alsharafi.dev/en/tags/rust/>rust</a></li></ul><nav class=paginav><a class=next href=https://amjad.alsharafi.dev/en/posts/wgmy2020/forensics/><span class=title>Next »</span><br><span>WGMY2020 - Forensic - Lord Kiske's Server</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Operating System - Spinlocks on x" href="https://x.com/intent/tweet/?text=Operating%20System%20-%20Spinlocks&amp;url=https%3a%2f%2famjad.alsharafi.dev%2fen%2fposts%2foperating-system%2fspinlocks%2f&amp;hashtags=operatingsystem%2crust"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Operating System - Spinlocks on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2famjad.alsharafi.dev%2fen%2fposts%2foperating-system%2fspinlocks%2f&amp;title=Operating%20System%20-%20Spinlocks&amp;summary=Operating%20System%20-%20Spinlocks&amp;source=https%3a%2f%2famjad.alsharafi.dev%2fen%2fposts%2foperating-system%2fspinlocks%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Operating System - Spinlocks on reddit" href="https://reddit.com/submit?url=https%3a%2f%2famjad.alsharafi.dev%2fen%2fposts%2foperating-system%2fspinlocks%2f&title=Operating%20System%20-%20Spinlocks"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Operating System - Spinlocks on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2famjad.alsharafi.dev%2fen%2fposts%2foperating-system%2fspinlocks%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Operating System - Spinlocks on whatsapp" href="https://api.whatsapp.com/send?text=Operating%20System%20-%20Spinlocks%20-%20https%3a%2f%2famjad.alsharafi.dev%2fen%2fposts%2foperating-system%2fspinlocks%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Operating System - Spinlocks on telegram" href="https://telegram.me/share/url?text=Operating%20System%20-%20Spinlocks&amp;url=https%3a%2f%2famjad.alsharafi.dev%2fen%2fposts%2foperating-system%2fspinlocks%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Operating System - Spinlocks on ycombinator" href="https://news.ycombinator.com/submitlink?t=Operating%20System%20-%20Spinlocks&u=https%3a%2f%2famjad.alsharafi.dev%2fen%2fposts%2foperating-system%2fspinlocks%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://amjad.alsharafi.dev/en/>Amjad Alsharafi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>